{"version":3,"sources":["src/room-store.js","src/directions.js","src/tile-paths2.js","src/index.js"],"names":["RoomStore","constructor","numCols","numRows","isLoaded","roomName","roomNumber","_tileCodeRows","_version","_getRequestInFlight","_targetRoomNumber","_unsavedEdits","_inFlightEdits","window","setInterval","_handleAmbientTick","bind","length","xhr","XMLHttpRequest","open","editRequest","_buildEditRequest","setRequestHeader","self","onload","status","concat","send","JSON","stringify","isSaved","roomResponse","parse","responseText","_handleRoomResponse","name","number","tileCodeRows","version","changeRoom","roomNum","getTileCode","row","col","Error","editTileCode","newTileCode","_replaceCharInStr","push","x","y","tileCode","existingVersion","tileEdits","slice","optionalNewName","str","index","replacement","substr","None","All","areEqual","dirA","dirB","fromCardinal","cardinal","toCardinal","dir","isNone","isVertical","isHorizontal","isDiagonal","toOrdinal","fromOrdinal","num","toRadians","Math","PI","fromArrows","left","right","up","down","isSameOrNextTo","ordA","ordB","actsOn","motionDir","pathDir","effect","reverse","rotateClockwise","numPoints","andEitherSide","chebyshevDistanceBetween","posA","posB","max","abs","euclideanDistanceBetween","sqrt","pow","bestDirBetween","fromPos","toPos","idealDist","bestDist","undefined","bestDir","tryDir","tryPos","tryDist","translateChebyshev","pos","distance","translateEuclidean","isOnLine","linePointPos","lineDir","tolerance","snapDist","snapToLine","addVec","a","b","subVec","scaleVec","v","s","relPos","snappedRelPos","mean","module","exports","directions","require","epsilon","quantize","tileSettings","currentPos","tileSize","tileCoords","floor","move","currentPose","tileCodeProvider","motionDistance","moves","computeMoves","idealPos","bestMove","tryMove","getTilePaths","minDist","tileSizeMinusMinDist","tilePaths","tileRelativeLinePos","startToEndDir","makeMovesUniqueStably","computeMovesR","originalPose","dubiousTileRelativePos","tileOriginPos","depth","tileCodeAt","tilePath","tileMoveSnapTolerance","tileRelativePos","maybeSnapToTilePath","remainingMotionDistance","possibleDirs","possibleDir","tileMoveResult","maybeMoveInTilePath","normal","achievedMotionDistance","stillRemainingMotionDistance","tileMoveResultToMoveResult","foundMoreMoves","ndtrp","generateNeighbouringDubiousTileRelativePositions","moreMoves","seenKeys","Set","keepMoves","key","has","add","effectOfMotion","unclippedNewTileRelativePos","distTooFar","outOfTileBy","offsetCoords","oppositeOffsetRelativePos","otherTileCoords","otherTileRelativePos","unclippedSnappedTileRelativePos","outOfBoundsBy","tileRelativeCentrePos","backInBoundsDir","backInBoundsTileRelativePos","reSnappedTileRelativePos","outOfTileByComponent","tileRelativePosComponent","roomStore","editMode","topBarSize","bottomBarSize","currentVelocity","initialVelocity","maxVelocity","myGamePiece1","myScore","myControlUp","myControlLeft","myControlRight","myControlDown","controlStates","keyMap","k37","k39","k38","k40","tileCodeToTileNum","startGame","addEventListener","e","myGameArea","keys","inputCode","keyCode","control","preventDefault","component","start","canvas","document","createElement","touchPositions","mousePosition","width","height","context","getContext","body","insertBefore","getElementById","frameNo","interval","updateGameArea","getPointerPos","mousePos","buttons","i","targetTouches","clear","clearRect","stop","clearInterval","pointerEvent","rect","getBoundingClientRect","clientX","clientY","top","type","color","text","spriteX","spriteY","spriteScale","angle","flip","update","ctx","font","fillStyle","fillText","img","save","imageSmoothingEnabled","translate","rotate","scale","drawImage","restore","fillRect","isClicked","touchPosition","touching","crashWith","otherobj","myleft","myright","mytop","mybottom","otherleft","otherright","othertop","otherbottom","crash","drawTiles","tileNum","tileChooserCurrentCode","tileChooserCodes","drawTileChooser","tx","ty","tileBorder","drawChosenTile","newPose","console","log","centrePos","everyinterval","n"],"mappings":"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","file":"src.96322081.js","sourceRoot":"..","sourcesContent":["export default class RoomStore {\r\n\r\n  constructor() {\r\n    this.numCols = 42;\r\n    this.numRows = 20;\r\n    this.isLoaded = false;\r\n    this.roomName = '';\r\n    this.roomNumber = '';\r\n    this._tileCodeRows = null;\r\n    this._version = 0;\r\n    this._getRequestInFlight = false;\r\n    this._targetRoomNumber = '';\r\n    this._unsavedEdits = [];\r\n    this._inFlightEdits = [];\r\n    window.setInterval(this._handleAmbientTick.bind(this), 1000);\r\n  }\r\n\r\n  _handleAmbientTick() {\r\n    if (this._unsavedEdits.length > 0 && this._inFlightEdits.length === 0) {\r\n      let xhr = new XMLHttpRequest();\r\n      xhr.open('PUT', 'https://antr.io/rooms/' + this.roomNumber);\r\n      let editRequest = this._buildEditRequest();\r\n      this._inFlightEdits = this._unsavedEdits;\r\n      this._unsavedEdits = [];\r\n      xhr.setRequestHeader('Content-Type', 'application/json');\r\n      let self = this;\r\n      xhr.onload = function() {\r\n        if (xhr.status === 204) {\r\n          self._inFlightEdits = [];\r\n          self._version++;\r\n        } else {\r\n          self._unsavedEdits = self._inFlightEdits.concat(self._unsavedEdits);\r\n          self._inFlightEdits = [];\r\n        }\r\n      };\r\n      xhr.send(JSON.stringify(editRequest));\r\n      return;\r\n    }\r\n    if (this._targetRoomNumber !== this.roomNumber && !this._getRequestInFlight && this.isSaved()) {\r\n      this.isLoaded = false;\r\n      this.roomName = 'Loading ...';\r\n      let xhr = new XMLHttpRequest();\r\n      xhr.open('GET', 'https://antr.io/rooms/' + this._targetRoomNumber);\r\n      xhr.setRequestHeader('Content-Type', 'application/json');\r\n      let self = this;\r\n      xhr.onload = function() {\r\n        if (xhr.status === 200) {\r\n          let roomResponse = JSON.parse(xhr.responseText);\r\n          self._handleRoomResponse(roomResponse);\r\n        }\r\n        self._getRequestInFlight = false;\r\n      };\r\n      this._getRequestInFlight = true;\r\n      xhr.send();\r\n      return;\r\n    }\r\n  }\r\n\r\n  _handleRoomResponse(roomResponse) {\r\n    this.roomName = roomResponse.name;\r\n    this.roomNumber = roomResponse.number;\r\n    this._tileCodeRows = roomResponse.tileCodeRows;\r\n    this._version = roomResponse.version;\r\n    this.isLoaded = true;\r\n  }\r\n\r\n  isSaved() {\r\n    return this._unsavedEdits.length === 0 && this._inFlightEdits.length === 0;\r\n  }\r\n\r\n  changeRoom(roomNum) {\r\n    let roomNumber = '' + roomNum;\r\n    this._targetRoomNumber = roomNumber;\r\n    this.isLoaded = false;\r\n    this.roomName = 'Loading ...';\r\n  }\r\n\r\n  getTileCode(row, col) {\r\n    if (!this.isLoaded) {\r\n      throw new Error('cannot get tiles for room that has not loaded');\r\n    }\r\n    return this._tileCodeRows[row][col];\r\n  }\r\n\r\n  editTileCode(row, col, newTileCode) {\r\n    if (!this.isLoaded) {\r\n      throw new Error('cannot edit room that has not loaded');\r\n    }\r\n    // TODO - check bounds?\r\n    this._tileCodeRows[row] = this._replaceCharInStr(this._tileCodeRows[row], col, newTileCode);\r\n    this._unsavedEdits.push({\r\n      x: col,\r\n      y: row,\r\n      tileCode: newTileCode\r\n    })\r\n  }\r\n\r\n  _buildEditRequest() {\r\n    return {\r\n      number: this.roomNumber,\r\n      existingVersion: this._version,\r\n      tileEdits: this._unsavedEdits.slice(),\r\n      optionalNewName: null\r\n    }\r\n  }\r\n\r\n  _replaceCharInStr(str, index, replacement) {\r\n    return str.substr(0, index) + replacement + str.substr(index + replacement.length);\r\n  }\r\n\r\n}\r\n","/*\r\n * antR.io uses a slightly unusual geometry (sometimes called Chebyshev distance or chess-board distance) where:\r\n *  1) the only movement directions are the 8 cardinal compass points (N, NE, E, SE, S, SW, W, NW)\r\n *     (well, and there's a 'Z' to represent not moving at all - not sure how useful really)\r\n *  2) moving one unit NE is the same as moving one unit N and one unit E\r\n *     (e.g. moving from [1,1] to [3,3] is the same distance as moving from [1,1] to [3,1])\r\n*/\r\n\r\nconst None = 'Z';\r\n\r\nconst All = ['Z','N','NE','E','SE','S','SW','W','NW'];\r\n\r\nfunction areEqual(dirA, dirB) {\r\n  return dirA === dirB;\r\n}\r\n\r\nfunction fromCardinal(cardinal) {\r\n  switch (cardinal) {\r\n    case 'N':\r\n    case 'NE':\r\n    case 'E':\r\n    case 'SE':\r\n    case 'S':\r\n    case 'SW':\r\n    case 'W':\r\n    case 'NW':\r\n    case 'Z':\r\n      return cardinal;\r\n    default: throw new Error('unsupported direction ' + cardinal);\r\n  }\r\n}\r\n\r\nfunction toCardinal(dir) {\r\n  return dir;\r\n}\r\n\r\nfunction isNone(dir) {\r\n  return dir === 'Z';\r\n}\r\n\r\nfunction isVertical(dir) {\r\n  return dir === 'N' || dir === 'S';\r\n}\r\n\r\nfunction isHorizontal(dir) {\r\n  return dir === 'E' || dir === 'W';\r\n}\r\n\r\nfunction isDiagonal(dir) {\r\n  return dir === 'NE' || dir === 'SE' || dir === 'SW' || dir === 'NW';\r\n}\r\n\r\nfunction toOrdinal(dir) {\r\n  switch (dir) {\r\n    case 'N':  return 0;\r\n    case 'NE': return 1;\r\n    case 'E':  return 2;\r\n    case 'SE': return 3;\r\n    case 'S':  return 4;\r\n    case 'SW': return 5;\r\n    case 'W':  return 6;\r\n    case 'NW': return 7;\r\n    default: throw new Error('unsupported direction ' + dir);\r\n  }\r\n}\r\n\r\nfunction fromOrdinal(num) {\r\n  if (num < -8 || num > 15) {\r\n    throw new Error('out of range');\r\n  }\r\n  if (num < 0) {\r\n    num += 8;\r\n  } else if (num >= 8) {\r\n    num -= 8;\r\n  }\r\n  switch (num) {\r\n    case 0: return 'N';\r\n    case 1: return 'NE';\r\n    case 2: return 'E';\r\n    case 3: return 'SE';\r\n    case 4: return 'S';\r\n    case 5: return 'SW';\r\n    case 6: return 'W';\r\n    case 7: return 'NW';\r\n    default: throw new Error('unsupported ordinal ' + num);\r\n  }\r\n}\r\n\r\nfunction toRadians(dir) {\r\n  return (toOrdinal(dir) - 2) / 8.0 * Math.PI * 2.0;\r\n}\r\n\r\nfunction fromArrows(left, right, up, down) {\r\n  if (left && !right && !up && !down) {\r\n    return 'W';\r\n  } else if (!left && right && !up && !down) {\r\n    return 'E';\r\n  } else if (!left && !right && up && !down) {\r\n    return 'N';\r\n  } else if (left && !right && up && !down) {\r\n    return 'NW';\r\n  } else if (!left && right && up && !down) {\r\n    return 'NE';\r\n  } else if (!left && !right && !up && down) {\r\n    return 'S';\r\n  } else if (left && !right && !up && down) {\r\n    return 'SW';\r\n  } else if (!left && right && !up && down) {\r\n    return 'SE';\r\n  }\r\n  return 'Z';\r\n}\r\n\r\nfunction isSameOrNextTo(dirA, dirB) {\r\n  if (dirA === dirB) {\r\n    return true;\r\n  }\r\n  if (isNone(dirA) || isNone(dirB)) {\r\n    return false;\r\n  }\r\n  const ordA = toOrdinal(dirA);\r\n  const ordB = toOrdinal(dirB);\r\n  return ((ordA + 1) % 8) == ordB || ((ordB + 1) % 8) == ordA;\r\n}\r\n\r\nfunction actsOn(motionDir, pathDir) {\r\n  if (isSameOrNextTo(motionDir, pathDir)) {\r\n    return {\r\n      effect: 1,\r\n      dir: pathDir\r\n    };\r\n  } else if (isSameOrNextTo(reverse(motionDir), pathDir)) {\r\n    return {\r\n      effect: -1,\r\n      dir: reverse(pathDir)\r\n    };\r\n  } else {\r\n    return {\r\n      effect: 0,\r\n      dir: None\r\n    };\r\n  }\r\n}\r\n\r\nfunction reverse(dir) {\r\n  return rotateClockwise(dir, 4);\r\n}\r\n\r\nfunction rotateClockwise(dir, numPoints) {\r\n  if (numPoints < -8 || numPoints > 8) {\r\n    throw new Error('out of range');\r\n  }\r\n  if (isNone(dir)) {\r\n    return dir;\r\n  }\r\n  return fromOrdinal(toOrdinal(dir) + numPoints);\r\n}\r\n\r\nfunction andEitherSide(dir) {\r\n  if (isNone(dir)) {\r\n    return [dir];\r\n  }\r\n  return [\r\n    dir,\r\n    rotateClockwise(dir, -1),\r\n    rotateClockwise(dir, +1)\r\n  ];\r\n}\r\n\r\n// distance is never negative\r\nfunction chebyshevDistanceBetween(posA, posB) {\r\n  return Math.max(Math.abs(posA[0] - posB[0]), Math.abs(posA[1] - posB[1]));\r\n}\r\n\r\n// back in the real-world, how far is it between two points?\r\nfunction euclideanDistanceBetween(posA, posB) {\r\n  return Math.sqrt(Math.pow(posA[0] - posB[0], 2) + Math.pow(posA[1] - posB[1], 2));\r\n}\r\n\r\n// the direction to move from fromPos to get closest to toPos\r\nfunction bestDirBetween(fromPos, toPos) {\r\n  const idealDist = chebyshevDistanceBetween(fromPos, toPos);\r\n  let bestDist = undefined;\r\n  let bestDir = undefined;\r\n  for (let tryDir of All) {\r\n    let tryPos = translateChebyshev(fromPos, tryDir, idealDist);\r\n    let tryDist = chebyshevDistanceBetween(tryPos, toPos);\r\n    if (!bestDir || tryDist < bestDist) {\r\n      bestDist = tryDist;\r\n      bestDir = tryDir;\r\n    }\r\n  }\r\n  return bestDir;\r\n}\r\n\r\n// distance can be negative (moves in reverse direction)\r\nfunction translateChebyshev(pos, dir, distance) {\r\n  switch (dir) {\r\n    case 'Z':  return [pos[0],pos[1]];\r\n    case 'N':  return [pos[0],pos[1]+distance];\r\n    case 'NE': return [pos[0]+distance,pos[1]+distance];\r\n    case 'E':  return [pos[0]+distance,pos[1]];\r\n    case 'SE': return [pos[0]+distance,pos[1]-distance];\r\n    case 'S':  return [pos[0],pos[1]-distance];\r\n    case 'SW': return [pos[0]-distance,pos[1]-distance];\r\n    case 'W':  return [pos[0]-distance,pos[1]];\r\n    case 'NW': return [pos[0]-distance,pos[1]+distance];\r\n    default: throw new Error('unsupported direction ' + dir);\r\n  }\r\n}\r\n\r\n// distance can be negative (moves in reverse direction)\r\nfunction translateEuclidean(pos, dir, distance) {\r\n  return translateChebyshev(pos, dir, isDiagonal(dir) ? distance * Math.sqrt(2) * 0.5: distance);\r\n}\r\n\r\nfunction isOnLine(linePointPos, lineDir, pos, tolerance) {\r\n  if (tolerance < 0) {\r\n    throw new Error('tolerance out of range');\r\n  }\r\n  const snappedPos = snapToLine(linePointPos, lineDir, pos);\r\n  const snapDist = chebyshevDistanceBetween(pos, snappedPos);\r\n  return snapDist < tolerance;\r\n}\r\n\r\nfunction addVec(a, b) {\r\n  return [a[0] + b[0], a[1] + b[1]];\r\n}\r\n\r\nfunction subVec(a, b) {\r\n  return [a[0] - b[0], a[1] - b[1]];\r\n}\r\n\r\nfunction scaleVec(v, s) {\r\n  return [v[0] * s, v[1] * s];\r\n}\r\n\r\nfunction snapToLine(linePointPos, lineDir, pos) {\r\n  const relPos = subVec(pos, linePointPos);\r\n  let snappedRelPos = undefined;\r\n  switch (lineDir) {\r\n    case 'Z': snappedRelPos = [0, 0]; break;\r\n    case 'N':  \r\n    case 'S': snappedRelPos = [0, relPos[1]]; break;\r\n    case 'E':  \r\n    case 'W': snappedRelPos = [relPos[0], 0]; break;\r\n    case 'NE': \r\n    case 'SW':\r\n      {\r\n        const mean = 0.5 * (relPos[0] + relPos[1]);\r\n        snappedRelPos = [mean, mean];\r\n        break;\r\n      }\r\n    case 'NW': \r\n    case 'SE':\r\n      {\r\n        const mean = 0.5 * (relPos[0] - relPos[1]);\r\n        snappedRelPos = [mean, -mean];\r\n        break;\r\n      }\r\n    default: throw new Error('bad direction ' + dir);\r\n  }\r\n  return addVec(snappedRelPos, linePointPos);\r\n}\r\n\r\nmodule.exports = {\r\n  None: None,\r\n  All: All,\r\n  areEqual: areEqual,\r\n  fromCardinal: fromCardinal,\r\n  fromArrows: fromArrows,\r\n  toCardinal: toCardinal,\r\n  toRadians: toRadians,\r\n  isNone: isNone,\r\n  isVertical: isVertical,\r\n  isHorizontal: isHorizontal,\r\n  isDiagonal: isDiagonal,\r\n  actsOn: actsOn,\r\n  reverse: reverse,\r\n  rotateClockwise: rotateClockwise,\r\n  andEitherSide: andEitherSide,\r\n  translateChebyshev: translateChebyshev,\r\n  translateEuclidean: translateEuclidean,\r\n  chebyshevDistanceBetween: chebyshevDistanceBetween,\r\n  euclideanDistanceBetween: euclideanDistanceBetween,\r\n  bestDirBetween: bestDirBetween,\r\n  snapToLine: snapToLine,\r\n  isOnLine: isOnLine,\r\n  addVec: addVec,\r\n  subVec: subVec,\r\n  scaleVec: scaleVec\r\n};\r\n","const directions = require('./directions');\r\n\r\nconst epsilon = 1e-8;\r\n\r\nfunction quantize(tileSettings, currentPos) {\r\n  const tileSize = tileSettings.tileSize;\r\n  const tileCoords = [ Math.floor(currentPos[0] / tileSize), Math.floor(currentPos[1] / tileSize) ];\r\n  const tileRelativePos = [ currentPos[0] - (tileCoords[0] * tileSize), currentPos[1] - (tileCoords[1] * tileSize) ];\r\n  const tileOriginPos = directions.scaleVec(tileCoords, tileSize);\r\n  return [tileCoords, tileRelativePos, tileOriginPos];\r\n}\r\n\r\nfunction move(currentPose, tileSettings, tileCodeProvider, motionDir, motionDistance) {\r\n  const moves = computeMoves(currentPose, tileSettings, tileCodeProvider, motionDir, motionDistance);\r\n  const idealPos = directions.translateChebyshev(currentPose.pos, motionDir, motionDistance);\r\n  let bestDist = undefined;\r\n  let bestMove = undefined;\r\n  for (let tryMove of moves.concat([currentPose])) {\r\n    let tryDist = directions.chebyshevDistanceBetween(tryMove.pos, idealPos);\r\n    if (!bestMove || tryDist < bestDist) {\r\n      bestDist = tryDist;\r\n      bestMove = tryMove;\r\n    }\r\n  }\r\n  return bestMove;\r\n}\r\n\r\nfunction getTilePaths(tileSettings, tileCode) {\r\n  const tileSize = tileSettings.tileSize;\r\n  const minDist = tileSettings.minDist;\r\n  const tileSizeMinusMinDist = tileSize - minDist;\r\n  let tilePaths = [];\r\n  if (tileCode === 'v') { // grass-at-top\r\n    tilePaths = [ {\r\n      tileRelativeLinePos: [0, tileSizeMinusMinDist],\r\n      startToEndDir: directions.fromCardinal('E')\r\n    } ]\r\n  } else if (tileCode === 'q') { // grass-at-right\r\n    tilePaths = [ {\r\n      tileRelativeLinePos: [tileSizeMinusMinDist, tileSize],\r\n      startToEndDir: directions.fromCardinal('S')\r\n    } ]\r\n  } else if (tileCode === 'm') { // grass-at-bottom\r\n    tilePaths = [ {\r\n      tileRelativeLinePos: [tileSize, minDist],\r\n      startToEndDir: directions.fromCardinal('W')\r\n    } ]\r\n  } else if (tileCode === 'p') { // grass-at-left\r\n    tilePaths = [ {\r\n      tileRelativeLinePos: [minDist, 0],\r\n      startToEndDir: directions.fromCardinal('N')\r\n    } ]\r\n  } else if (tileCode === 'w') { // grass-up-and-right-above\r\n    tilePaths = [ {\r\n      tileRelativeLinePos: [0, 0],\r\n      startToEndDir: directions.fromCardinal('NE')\r\n    } ]\r\n  } else if (tileCode === 'u') { // grass-down-and-right-above\r\n    tilePaths = [ {\r\n      tileRelativeLinePos: [0, tileSize],\r\n      startToEndDir: directions.fromCardinal('SE')\r\n    } ]\r\n  } else if (tileCode === 'l') { // grass-down-and-left-below\r\n    tilePaths = [ {\r\n      tileRelativeLinePos: [tileSize, tileSize],\r\n      startToEndDir: directions.fromCardinal('SW')\r\n    } ]\r\n  } else if (tileCode === 'n') { // grass-up-and-left-below\r\n    tilePaths = [ {\r\n      tileRelativeLinePos: [tileSize, 0],\r\n      startToEndDir: directions.fromCardinal('NW')\r\n    } ]\r\n  }\r\n  return tilePaths;\r\n}\r\n\r\nfunction computeMoves(currentPose, tileSettings, tileCodeProvider, motionDir, motionDistance) {\r\n  const [tileCoords, tileRelativePos, tileOriginPos] = quantize(tileSettings, currentPose.pos);\r\n  const moves = computeMovesR(currentPose, tileSettings, tileCodeProvider, tileCoords, tileRelativePos, tileOriginPos, motionDir, motionDistance, 0);\r\n  return makeMovesUniqueStably(moves);\r\n}\r\n\r\nfunction computeMovesR(originalPose, tileSettings, tileCodeProvider, tileCoords, dubiousTileRelativePos, tileOriginPos, motionDir, motionDistance, depth) {\r\n  if (motionDistance < -epsilon) {\r\n    throw new Error('motionDistance cannot be negative');\r\n  }\r\n  if (motionDistance < tileSettings.minDist) {\r\n    return [];\r\n  }\r\n  if (directions.isNone(motionDir)) {\r\n    return [];\r\n  }\r\n  const tileCode = tileCodeProvider.tileCodeAt(tileCoords);\r\n  const tilePaths = getTilePaths(tileSettings, tileCode);\r\n  if (tilePaths.length < 1) {\r\n    return [];\r\n  }\r\n  if (tilePaths.length > 1) {\r\n    throw new Error('multiple paths in one tile not supported');\r\n  }\r\n  const tilePath = tilePaths[0];\r\n  const tileMoveSnapTolerance = tileSettings.minDist * 2 + epsilon;\r\n  const snapTolerance = depth == 0 ? epsilon : tileMoveSnapTolerance;\r\n  const tileRelativePos = maybeSnapToTilePath(tileSettings, tilePath, dubiousTileRelativePos, snapTolerance);\r\n  if (!tileRelativePos) {\r\n    return [];\r\n  }\r\n  const snapDist = directions.chebyshevDistanceBetween(dubiousTileRelativePos, tileRelativePos);\r\n  if (snapDist > motionDistance) {\r\n    return [];\r\n  }\r\n  let remainingMotionDistance = motionDistance - snapDist;\r\n  const moves = [];\r\n  const possibleDirs = directions.andEitherSide(motionDir);\r\n  for (let possibleDir of possibleDirs) {\r\n    let tileMoveResult = maybeMoveInTilePath(tileSettings, tilePath, tileRelativePos, possibleDir, remainingMotionDistance);\r\n    if (!tileMoveResult) {\r\n      tileMoveResult = {\r\n        tileRelativePos: tileRelativePos,\r\n        dir: originalPose.dir,\r\n        normal: directions.rotateClockwise(tilePath.startToEndDir, -2)\r\n      };\r\n    }\r\n    let achievedMotionDistance = directions.chebyshevDistanceBetween(tileRelativePos, tileMoveResult.tileRelativePos);\r\n    let stillRemainingMotionDistance = remainingMotionDistance - achievedMotionDistance;\r\n    if (stillRemainingMotionDistance < tileSettings.minDist + epsilon) {\r\n      moves.push(tileMoveResultToMoveResult(tileMoveResult, tileOriginPos));\r\n      continue;\r\n    }\r\n    let foundMoreMoves = false;\r\n    if (depth == 0) {\r\n      for (let ndtrp of generateNeighbouringDubiousTileRelativePositions(tileSettings, tileCoords, tileMoveResult.tileRelativePos)) {\r\n        let moreMoves = computeMovesR(originalPose, tileSettings, tileCodeProvider,\r\n          ndtrp.tileCoords,\r\n          ndtrp.dubiousTileRelativePos,\r\n          ndtrp.tileOriginPos,\r\n          motionDir, stillRemainingMotionDistance, depth + 1);\r\n        if (moreMoves.length > 0) {\r\n          foundMoreMoves = true;\r\n          moves.push(...moreMoves);\r\n        }\r\n      }\r\n    }\r\n    // TODO - maybe we should just always do this and let move choose the best ?\r\n    if (!foundMoreMoves) {\r\n      moves.push(tileMoveResultToMoveResult(tileMoveResult, tileOriginPos));\r\n    }\r\n  }\r\n  return moves;\r\n}\r\n\r\nfunction makeMovesUniqueStably(moves) {\r\n  const seenKeys = new Set();\r\n  const keepMoves = [];\r\n  for (let move of moves) {\r\n    let key = JSON.stringify(move);\r\n    if (seenKeys.has(key)) {\r\n      continue;\r\n    }\r\n    seenKeys.add(key)\r\n    keepMoves.push(move);\r\n  }\r\n  return keepMoves;\r\n}\r\n\r\nfunction tileMoveResultToMoveResult(tileMoveResult, tileOriginPos) {\r\n  return {\r\n    pos: addVec(tileOriginPos, tileMoveResult.tileRelativePos),\r\n    dir: tileMoveResult.dir,\r\n    normal: tileMoveResult.normal\r\n  }\r\n}\r\n\r\nfunction addVec(posA, posB) {\r\n  return [posA[0] + posB[0], posA[1] + posB[1]];\r\n}\r\n\r\nfunction maybeMoveInTilePath(tileSettings, tilePath, tileRelativePos, motionDir, motionDistance) {\r\n  if (motionDistance < -epsilon) {\r\n    throw new Error('motionDistance cannot be negative');\r\n  }\r\n  if (motionDistance < tileSettings.minDist) {\r\n    return undefined;\r\n  }\r\n  if (directions.isNone(motionDir)) {\r\n    return undefined;\r\n  }\r\n  const effectOfMotion = directions.actsOn(motionDir, tilePath.startToEndDir);\r\n  if (effectOfMotion.effect == 0) {\r\n    return undefined;\r\n  }\r\n  const unclippedNewTileRelativePos = directions.translateChebyshev(tileRelativePos, effectOfMotion.dir, motionDistance);\r\n  const distTooFar = outOfTileBy(tileSettings, unclippedNewTileRelativePos);\r\n  const newTileRelativePos = directions.translateChebyshev(unclippedNewTileRelativePos, effectOfMotion.dir, -distTooFar);\r\n  return {\r\n    tileRelativePos: newTileRelativePos,\r\n    dir: effectOfMotion.dir,\r\n    normal: directions.rotateClockwise(tilePath.startToEndDir, -2)\r\n  }\r\n}\r\n\r\nfunction* generateNeighbouringDubiousTileRelativePositions(tileSettings, tileCoords, tileRelativePos) {\r\n  for (let dir of directions.All) {\r\n    if (directions.isNone(dir)) {\r\n      continue;\r\n    }\r\n    let offsetCoords = directions.translateChebyshev([0,0], dir, 1);\r\n    let oppositeOffsetRelativePos = directions.translateChebyshev([0,0], dir, -tileSettings.tileSize);\r\n    let otherTileCoords = directions.addVec(tileCoords, offsetCoords);\r\n    let otherTileRelativePos = directions.addVec(tileRelativePos, oppositeOffsetRelativePos);\r\n    yield {\r\n      tileCoords: otherTileCoords,\r\n      dubiousTileRelativePos: otherTileRelativePos,\r\n      tileOriginPos: directions.scaleVec(otherTileCoords, tileSettings.tileSize)\r\n    };\r\n  }\r\n}\r\n\r\nfunction maybeSnapToTilePath(tileSettings, tilePath, dubiousTileRelativePos, tolerance) {\r\n  const unclippedSnappedTileRelativePos = directions.snapToLine(tilePath.tileRelativeLinePos, tilePath.startToEndDir, dubiousTileRelativePos);\r\n  const outOfBoundsBy = outOfTileBy(tileSettings, unclippedSnappedTileRelativePos);\r\n  // TODO - using the centre is a bit questionable\r\n  const tileRelativeCentrePos = [0.5 * tileSettings.tileSize, 0.5 * tileSettings.tileSize];\r\n  const backInBoundsDir = directions.bestDirBetween(unclippedSnappedTileRelativePos, tileRelativeCentrePos);\r\n  const backInBoundsTileRelativePos = directions.translateChebyshev(unclippedSnappedTileRelativePos, backInBoundsDir, outOfBoundsBy);\r\n  const reSnappedTileRelativePos = directions.snapToLine(tilePath.tileRelativeLinePos, tilePath.startToEndDir, backInBoundsTileRelativePos);\r\n  const snapDist = directions.chebyshevDistanceBetween(dubiousTileRelativePos, reSnappedTileRelativePos);\r\n  if (snapDist < tolerance) {\r\n    return reSnappedTileRelativePos;\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\nfunction outOfTileBy(tileSettings, tileRelativePos) {\r\n  return Math.max(outOfTileByComponent(tileSettings, tileRelativePos[0]), outOfTileByComponent(tileSettings, tileRelativePos[1]));\r\n}\r\n\r\nfunction outOfTileByComponent(tileSettings, tileRelativePosComponent) {\r\n  // TODO - should this be minDist or epsilon?\r\n  const tileSizeMinusMinDist = tileSettings.tileSize - tileSettings.minDist;\r\n  if (tileRelativePosComponent < 0) {\r\n    return 0 - tileRelativePosComponent;\r\n  }\r\n  if (tileRelativePosComponent > tileSizeMinusMinDist) {\r\n    return tileRelativePosComponent - tileSizeMinusMinDist;\r\n  }\r\n  return 0;\r\n}\r\n\r\nmodule.exports = {\r\n  quantize: quantize,\r\n  move: move,\r\n  computeMoves: computeMoves\r\n};\r\n","import RoomStore from './room-store.js';\r\nconst tilePaths = require('./tile-paths2');\r\nconst directions = require('./directions');\r\n\r\nconst roomStore = new RoomStore();\r\nlet editMode = false;\r\n\r\nconst topBarSize = 28;\r\nconst bottomBarSize = 28;\r\nconst tileSize = 16;\r\nconst tileSettings = {\r\n  tileSize: tileSize,\r\n  minDist: 0.01\r\n};\r\n\r\nlet currentPose = {\r\n  pos: [160, 96 - tileSettings.minDist],\r\n  dir: directions.fromCardinal('E'),\r\n  normal: directions.fromCardinal('N'),\r\n};\r\nlet currentVelocity = 0.0;\r\n\r\nconst initialVelocity = 1.0;\r\nconst maxVelocity = 2.5;\r\nconst tileCodeProvider = {\r\n  tileCodeAt: function (tileCoords) {\r\n    const col = tileCoords[0];\r\n    const row = roomStore.numRows - tileCoords[1] - 1;\r\n    const tileCode = roomStore.getTileCode(row, col);\r\n    return tileCode;\r\n  }\r\n};\r\n\r\nlet myGamePiece1 = undefined;\r\nlet myScore = undefined;\r\nlet myControlUp = undefined;\r\nlet myControlLeft = undefined;\r\nlet myControlRight = undefined;\r\nlet myControlDown = undefined;\r\n\r\nconst controlStates = {}; \r\nconst keyMap = {\r\n  k37: \"left\",\r\n  k39: \"right\",\r\n  k38: \"up\",\r\n  k40: \"down\"\r\n};\r\nconst tileCodeToTileNum = {\r\n  \" \" : 1,\r\n  \".\" : 2,\r\n  \"l\" : 9,\r\n  \"m\" : 5,\r\n  \"n\" : 10,\r\n  \"q\" : 4,\r\n  \"p\" : 6,\r\n  \"u\" : 8,\r\n  \"v\" : 3,\r\n  \"w\" : 7\r\n};\r\n\r\nfunction startGame() {\r\n  roomStore.changeRoom(5050);\r\n  window.addEventListener(\"keydown\", function (e) {\r\n    myGameArea.keys = (myGameArea.keys || []);\r\n    var inputCode = [\"k\" + e.keyCode];\r\n    var control = keyMap[inputCode];\r\n    if (control) {\r\n      controlStates[control] = true;\r\n      e.preventDefault();\r\n    }\r\n  });\r\n  window.addEventListener(\"keyup\", function (e) {\r\n    if (e.keyCode === 69) { // key e\r\n      editMode = !editMode;\r\n      e.preventDefault();\r\n      return;\r\n    }\r\n    var control = keyMap[\"k\" + e.keyCode];\r\n    if (control) {\r\n      controlStates[control] = false;\r\n      e.preventDefault();\r\n    }\r\n  });\r\n  myGamePiece1 = new component(160, 257, 16, 16, \"sprite\", \"\", \"\", 0, 16, 2);\r\n  myScore = new component(16, 14, 0, 0, \"text\", \"black\", \"\");\r\n  myControlUp = new component(60, 240, 42, 42, \"sprite\", \"\", \"\", 52, 0, 2);\r\n  myControlLeft = new component(25, 275, 42, 44, \"sprite\", \"\", \"\", 10, 0, 2);\r\n  myControlRight = new component(95, 275, 42, 44, \"sprite\", \"\", \"\", 31, 0, 2);\r\n  myControlDown = new component(60, 310, 42, 42, \"sprite\", \"\", \"\", 74, 0, 2);\r\n  myGameArea.start();\r\n}\r\n\r\nconst myGameArea = {\r\n  canvas: document.createElement(\"canvas\"),\r\n  touchPositions: [],\r\n  mousePosition: null,\r\n  start : function() {\r\n    this.canvas.width = roomStore.numCols * tileSize;\r\n    this.canvas.height = topBarSize + roomStore.numRows * tileSize + bottomBarSize;\r\n    this.context = this.canvas.getContext(\"2d\");\r\n    document.body.insertBefore(this.canvas, document.getElementById(\"gameAreaHolder\"));\r\n\r\n    this.frameNo = 0;\r\n    this.interval = setInterval(updateGameArea, 20);\r\n    let self = this;\r\n    this.canvas.addEventListener(\"mousedown\", function (e) {\r\n      self.touchPositions = [ self.getPointerPos(e) ];\r\n      e.preventDefault();\r\n    }, false);\r\n    this.canvas.addEventListener(\"mouseup\", function (e) {\r\n      self.touchPositions = [];\r\n      e.preventDefault();\r\n    }, false);\r\n    this.canvas.addEventListener(\"mousemove\", function (e) {\r\n      var mousePos = self.getPointerPos(e);\r\n      self.mousePosition = mousePos;\r\n      if (e.buttons > 0) {\r\n        self.touchPositions = [ mousePos ];\r\n      }\r\n      e.preventDefault();\r\n    }, false);\r\n    this.canvas.addEventListener(\"touchstart\", function (e) {\r\n      self.touchPositions = [];\r\n      for (var i = 0; i < e.targetTouches.length; i++) {\r\n        self.touchPositions.push(self.getPointerPos(e.targetTouches[i]));\r\n      }\r\n      e.preventDefault();\r\n    }, false);\r\n    this.canvas.addEventListener(\"touchend\", function (e) {\r\n      self.touchPositions = [];\r\n      for (var i = 0; i < e.targetTouches.length; i++) {\r\n        self.touchPositions.push(self.getPointerPos(e.targetTouches[i]));\r\n      }\r\n      e.preventDefault();\r\n    }, false);\r\n    this.canvas.addEventListener(\"touchmove\", function (e) {\r\n      self.touchPositions = [];\r\n      for (var i = 0; i < e.targetTouches.length; i++) {\r\n        self.touchPositions.push(self.getPointerPos(e.targetTouches[i]));\r\n      }\r\n      e.preventDefault();\r\n    }, false);\r\n  },\r\n  clear : function() {\r\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n  },\r\n  stop : function() {\r\n    clearInterval(this.interval);\r\n  },\r\n  getPointerPos : function(pointerEvent) {\r\n    const rect = this.canvas.getBoundingClientRect();\r\n    return {\r\n      x: pointerEvent.clientX - rect.left,\r\n      y: pointerEvent.clientY - rect.top\r\n    };\r\n  }\r\n}\r\n\r\nfunction component(x, y, width, height, type, color, text, spriteX, spriteY, spriteScale) {\r\n  this.body = null;\r\n  this.x = x;\r\n  this.y = y;\r\n  this.angle = 0;\r\n  this.flip = false;\r\n  this.width = width;\r\n  this.height = height;\r\n  this.type = type;\r\n  this.text = text;\r\n  this.color = color;\r\n  this.spriteX = spriteX;\r\n  this.spriteY = spriteY;\r\n  this.update = function() {\r\n    const ctx = myGameArea.context;\r\n    if (this.type == \"text\") {\r\n        ctx.font = \"18px Consolas\";\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillText(this.text, this.x, this.y);\r\n    } else if (this.type == \"sprite\") {\r\n      var img = document.getElementById(\"sprites\");\r\n      ctx.save();\r\n      ctx.imageSmoothingEnabled = false;\r\n      ctx.translate(this.x,this.y);\r\n      ctx.rotate(this.angle);\r\n      if (this.flip) {\r\n        ctx.scale(1, -1);\r\n      }\r\n      ctx.drawImage(img,this.spriteX,this.spriteY,this.width/spriteScale,this.height/spriteScale,-this.width/2,-this.height/2,this.width,this.height);\r\n      ctx.restore();\r\n    } else if (this.type == \"rect\") {\r\n      ctx.save();\r\n      ctx.fillStyle = color;\r\n      ctx.translate(this.x,this.y);\r\n      ctx.rotate(this.angle);\r\n      ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);\r\n      ctx.restore();\r\n    }\r\n  };\r\n  this.isClicked = function() {\r\n    for (let i = 0; i < myGameArea.touchPositions.length; i++) {\r\n      let touchPosition = myGameArea.touchPositions[i];\r\n      let touching = this.crashWith({\r\n        x: touchPosition.x,\r\n        y: touchPosition.y,\r\n        width: 0.5,\r\n        height: 0.5,\r\n      });\r\n      if (touching) return true;\r\n    }\r\n    return false;\r\n  };\r\n  this.crashWith = function(otherobj) {\r\n    var myleft = this.x - this.width/2;\r\n    var myright = this.x + this.width/2;\r\n    var mytop = this.y - this.height/2;\r\n    var mybottom = this.y + this.height/2\r\n    var otherleft = otherobj.x - otherobj.width/2;\r\n    var otherright = otherobj.x + otherobj.width/2;\r\n    var othertop = otherobj.y - otherobj.height/2;\r\n    var otherbottom = otherobj.y + otherobj.height/2;\r\n    var crash = true;\r\n    if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {\r\n        crash = false;\r\n    }\r\n    return crash;\r\n  };\r\n}\r\n\r\nfunction drawTiles() {\r\n  for (var row = 0; row < roomStore.numRows; row++) {\r\n    for (var col = 0; col < roomStore.numCols; col++) {\r\n      var tileCode = roomStore.getTileCode(row, col);\r\n      var tileNum = tileCodeToTileNum[tileCode];\r\n      if (!tileNum) tileNum = 1;\r\n      var tx = col * tileSize + tileSize/2;\r\n      var ty = topBarSize + row * tileSize + tileSize/2;\r\n      var tileComp = new component(tx, ty, 16, 16, \"sprite\", \"\", \"\", (tileNum-1)*9, 26, 2);\r\n      tileComp.update();\r\n    }\r\n  }\r\n}\r\n\r\nvar tileChooserCurrentCode = \" \";\r\nvar tileChooserCodes = [\" \", \".\", \"l\", \"m\", \"n\", \"q\", \"p\", \"u\", \"v\", \"w\"];\r\nfunction drawTileChooser() {\r\n  for (var i = 0; i < tileChooserCodes.length; i++) {\r\n    var tileCode = tileChooserCodes[i];\r\n    var tileNum = tileCodeToTileNum[tileCode];\r\n    var tx = 120 + i * (tileSize + 8);\r\n    var ty = tileSize/2 + 6;\r\n    var tileBorderColour = (tileCode === tileChooserCurrentCode) ? \"#ff8888\" : \"#dddddd\";\r\n    var tileBorder = new component(tx, ty, 20, 20, \"rect\", tileBorderColour);\r\n    tileBorder.update();\r\n    if (tileBorder.isClicked()) {\r\n      tileChooserCurrentCode = tileCode;\r\n    }\r\n    var tileComp = new component(tx, ty, 16, 16, \"sprite\", \"\", \"\", (tileNum-1)*9, 26, 2);\r\n    tileComp.update();\r\n  }\r\n}\r\n\r\nfunction drawChosenTile() {\r\n  if (myGameArea.mousePosition) {\r\n    var x = myGameArea.mousePosition.x;\r\n    var y = myGameArea.mousePosition.y - topBarSize;\r\n    var row = Math.floor(y / tileSize);\r\n    var col = Math.floor(x / tileSize);\r\n    if (row <= 0 || row >= roomStore.numRows - 1) return;\r\n    if (col <= 0 || col >= roomStore.numCols - 1) return;\r\n    var tx = col * tileSize + tileSize/2;\r\n    var ty = topBarSize + row * tileSize + tileSize/2;\r\n    var tileNum = tileCodeToTileNum[tileChooserCurrentCode];\r\n    var tileBorderColour = \"#ff8888\";\r\n    var tileBorder = new component(tx, ty, 20, 20, \"rect\", tileBorderColour);\r\n    tileBorder.update();\r\n    if (tileBorder.isClicked()) {\r\n      roomStore.editTileCode(row, col, tileChooserCurrentCode);\r\n    }\r\n    var tileComp = new component(tx, ty, 16, 16, \"sprite\", \"\", \"\", (tileNum-1)*9, 26, 2.5);\r\n    tileComp.update();\r\n  }\r\n}\r\n\r\nfunction updateGameArea() {\r\n\r\n    myGameArea.clear();\r\n\r\n    if (!roomStore.isLoaded) {\r\n      myScore.text = \"Loading ...\";\r\n      myScore.update();\r\n      return;\r\n    }\r\n\r\n    if (editMode) {\r\n      myScore.text = \"Edit Mode\";\r\n      myScore.update();\r\n      drawTileChooser();\r\n      drawTiles();\r\n      drawChosenTile();\r\n      return;\r\n    }\r\n\r\n    myGameArea.frameNo += 1;\r\n\r\n    const motionDir = directions.fromArrows(\r\n      controlStates[\"left\"] || myControlLeft.isClicked(),\r\n      controlStates[\"right\"] || myControlRight.isClicked(),\r\n      controlStates[\"up\"] || myControlUp.isClicked(),\r\n      controlStates[\"down\"] || myControlDown.isClicked()\r\n    );\r\n    if (!directions.isNone(motionDir)) {\r\n      currentVelocity += 0.25;\r\n      if (currentVelocity > maxVelocity) {\r\n        currentVelocity = maxVelocity;\r\n      }\r\n    } else {\r\n      currentVelocity = initialVelocity;\r\n    }\r\n\r\n    const newPose = tilePaths.move(currentPose, tileSettings, tileCodeProvider, motionDir, currentVelocity);\r\n    currentPose = newPose;\r\n\r\n    myGamePiece1.angle = directions.toRadians(currentPose.dir);\r\n    myGamePiece1.flip = !directions.areEqual(currentPose.dir, directions.rotateClockwise(currentPose.normal, 2));\r\n    console.log(myGamePiece1.flip, myGamePiece1.angle / Math.PI * 180);\r\n    const centrePos = directions.translateEuclidean(currentPose.pos, currentPose.normal, myGamePiece1.height / 2);\r\n    myGamePiece1.x = centrePos[0];\r\n    myGamePiece1.y = topBarSize + roomStore.numRows * tileSize - centrePos[1];\r\n\r\n    myScore.text = roomStore.roomName;\r\n    drawTiles();\r\n    myScore.update();\r\n    myGamePiece1.update();\r\n    myControlUp.update();\r\n    myControlLeft.update();\r\n    myControlRight.update();\r\n    myControlDown.update();\r\n}\r\n\r\nfunction everyinterval(n) {\r\n    if ((myGameArea.frameNo / n) % 1 == 0) {return true;}\r\n    return false;\r\n}\r\n\r\nwindow.addEventListener('load', startGame, false);\r\n"]}